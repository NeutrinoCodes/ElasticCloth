/// @file

// OPENGL:
#define INTEROP    true                                                                             // "true" = use OpenGL-OpenCL interoperability.
#define GUI_SIZE_X 800                                                                              // Window x-size [px].
#define GUI_SIZE_Y 600                                                                              // Window y-size [px].
#define GUI_NAME   "neutrino 3.0"                                                                   // Window name.

#ifdef __linux__
  #define SHADER_HOME \
  "/run/media/ezor/LINUX/BookhouseBoys/ezor/ElasticCloth/Code/shader"                               // Linux OpenGL shaders directory.

  #define KERNEL_HOME \
  "/run/media/ezor/LINUX/BookhouseBoys/ezor/ElasticCloth/Code/kernel"                               // Linux OpenCL kernels directory.
#endif

#ifdef __APPLE__
  #define SHADER_HOME \
  "/Users/Erik/Documents/PROJECTS/BookhouseBoys/ezor/ElasticCloth/Code/shader"                      // Mac OpenGL shaders directory.

  #define KERNEL_HOME \
  "/Users/Erik/Documents/PROJECTS/BookhouseBoys/ezor/ElasticCloth/Code/kernel"                      // Mac OpenCL kernels directory.
#endif

#ifdef WIN32
  #define SHADER_HOME "F:\\BookHouseBoys\\ezor\\elastic_cloth\\Code\\shader"                        // Windows OpenGL shaders directory.
  #define KERNEL_HOME "F:\\BookHouseBoys\\ezor\\elastic_cloth\\Code\\kernel"                        // Windows OpenCL kernels directory.
#endif

#define SHADER_VERT   "voxel_vertex.vert"                                                           // OpenGL vertex shader.
#define SHADER_GEOM   "voxel_geometry.geom"                                                         // OpenGL geometry shader.
#define SHADER_FRAG   "voxel_fragment.frag"                                                         // OpenGL fragment shader.

// OPENCL:
#define QUEUE_NUM     1                                                                             // # of OpenCL queues [#].
#define KERNEL_NUM    2                                                                             // # of OpenCL kernel [#].

#define KERNEL_F1     "thekernel1.cl"                                                               // OpenCL kernel.
#define KERNEL_F2     "thekernel2.cl"                                                               // OpenCL kernel.

// INCLUDES:
#include "opengl.hpp"                                                                               // Neutrino's OpenGL context declarations.
#include "opencl.hpp"                                                                               // Neutrino's OpenCL context declarations.

int main ()
{
  // DATA:
  float     x_min            = -1.0;                                                                // "x_min" spatial boundary [m].
  float     x_max            = +1.0;                                                                // "x_max" spatial boundary [m].
  float     y_min            = -1.0;                                                                // "y_min" spatial boundary [m].
  float     y_max            = +1.0;                                                                // "y_max" spatial boundary [m].
  size_t    nodes_x          = 100;                                                                 // # of nodes in "X" direction [#].
  size_t    nodes_y          = 100;                                                                 // # of nodes in "Y" direction [#].
  size_t    nodes            = nodes_x*nodes_y;                                                     // Total # of nodes [#].
  float     dx               = (x_max - x_min)/(nodes_x - 1);                                       // x-axis mesh spatial size [m].
  float     dy               = (y_max - y_min)/(nodes_y - 1);                                       // y-axis mesh spatial size [m].
  float     dz               = dx;                                                                  // z-axis mesh spatial size [m].
  size_t    i;                                                                                      // "x" direction index [#].
  size_t    j;                                                                                      // "y" direction index [#].
  size_t    gid;                                                                                    // Global index [#].
  size_t    border_R         = nodes_x - 1;                                                         // Cloth's right border index [#].
  size_t    border_U         = nodes_y - 1;                                                         // Cloth's up border index [#].
  size_t    border_L         = 0;                                                                   // Cloth's left border index [#].
  size_t    border_D         = 0;                                                                   // Cloth's down border index [#].
  size_t    neighbour_R;                                                                            // Right neighbour index [#].
  size_t    neighbour_U;                                                                            // Up neighbour index [#].
  size_t    neighbour_L;                                                                            // Left neighbour index [#].
  size_t    neighbour_D;                                                                            // Down neighbour index [#].

  // GUI PARAMETERS (orbit):
  float     orbit_x_init     = 0.0f;                                                                // x-axis orbit initial rotation.
  float     orbit_y_init     = 0.0f;                                                                // y-axis orbit initial rotation.
  float     orbit_x;                                                                                // x-axis orbit rotation.
  float     orbit_y;                                                                                // y-axis orbit rotation.
  float     orbit_decaytime  = 1.25;                                                                // Orbit LP filter decay time [s].
  float     orbit_deadzone   = 0.1;                                                                 // Orbit rotation deadzone [0...1].
  float     orbit_rate       = 1.0;                                                                 // Orbit rotation rate [rev/s].

  // GUI PARAMETERS (pan):
  float     pan_x_init       = 0.0f;                                                                // x-axis pan initial translation.
  float     pan_y_init       = 0.0f;                                                                // y-axis pan initial translation.
  float     pan_z_init       = -2.0f;                                                               // z-axis pan initial translation.
  float     pan_x;                                                                                  // x-axis pan translation.
  float     pan_y;                                                                                  // y-axis pan translation.
  float     pan_z;                                                                                  // z-axis pan translation.
  float     pan_decaytime    = 1.25;                                                                // Pan LP filter decay time [s].
  float     pan_deadzone     = 0.1;                                                                 // Pan rotation deadzone [0...1].
  float     pan_rate         = 1.0;                                                                 // Pan rotation rate [rev/s].

  // SIMULATION PARAMETERS:
  float     h                = 0.01;                                                                // Cloth's thickness [m].
  float     rho              = 1000.0;                                                              // Cloth's mass density [kg/m^3].
  float     E                = 100000.0;                                                            // Cloth's Young modulus [kg/(m*s^2)].
  float     mu               = 700.0;                                                               // Cloth's viscosity [Pa*s].
  float     m                = rho*h*dx*dy;                                                         // Cloth's mass [kg].
  float     g                = 9.81;                                                                // External gravity field [m/s^2].
  float     k                = E*h*dy/dx;                                                           // Cloth's elastic constant [kg/s^2].
  float     C                = mu*h*dx*dy;                                                          // Cloth's damping [kg*s*m].
  float     dt_critical      = sqrt (m/k);                                                          // Critical time step [s].
  float     dt_simulation    = 0.8* dt_critical;                                                    // Simulation time step [s].

  // NEUTRINO:
  neutrino* bas              = new neutrino ();                                                     // Neutrino baseline.
  opengl*   gui              = new opengl ();                                                       // OpenGL context.
  opencl*   ctx              = new opencl ();                                                       // OpenCL context.
  shader*   S                = new shader ();                                                       // OpenGL shader program.
  queue*    Q                = new queue ();                                                        // OpenCL queue.
  kernel*   K1               = new kernel ();                                                       // OpenCL kernel array.
  kernel*   K2               = new kernel ();                                                       // OpenCL kernel array.
  size_t    kernel_sx        = nodes;                                                               // Kernel dimension "x" [#].
  size_t    kernel_sy        = 0;                                                                   // Kernel dimension "y" [#].
  size_t    kernel_sz        = 0;                                                                   // Kernel dimension "z" [#].

  // NODE KINEMATICS:
  float4G*  position         = new float4G ();                                                      // Position [m].
  float4G*  depth            = new float4G ();                                                      // Depth [m].
  float4*   velocity         = new float4 ();                                                       // Velocity [m/s].
  float4*   acceleration     = new float4 ();                                                       // Acceleration [m/s^2].

  // NODE KINEMATICS (INTERMEDIATE):
  float4*   position_int     = new float4 ();                                                       // Position (intermediate) [m].
  float4*   velocity_int     = new float4 ();                                                       // Velocity (intermediate) [m/s].
  float4*   acceleration_int = new float4 ();                                                       // Acceleration (intermediate) [m/s^2].

  // NODE DYNAMICS:
  float4*   gravity          = new float4 ();                                                       // Gravity [m/s^2].
  float4*   stiffness        = new float4 ();                                                       // Stiffness.
  float4*   resting          = new float4 ();                                                       // Resting.
  float4*   friction         = new float4 ();                                                       // Friction.
  float4*   mass             = new float4 ();                                                       // Mass [kg].

  // MESH CONNECTIVITY:
  int1*     index_R          = new int1 ();                                                         // Right neighbour index [#].
  int1*     index_U          = new int1 ();                                                         // Up neighbour index [#].
  int1*     index_L          = new int1 ();                                                         // Left neighbour index [#].
  int1*     index_D          = new int1 ();                                                         // Down neighbour index [#].
  float4*   freedom          = new float4 ();                                                       // Freedom/constrain flag [#].

  // SIMULATION TIME:
  float1*   dt               = new float1 ();                                                       // Time step [s].
  float     simulation_time;                                                                        // Simulation time [s].
  int       time_step_index;                                                                        // Time step index [#].

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////// DATA INITIALIZATION //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  position->init (nodes);                                                                           // Initializing position data...
  depth->init (nodes);                                                                              // Initializing depth data...
  velocity->init (nodes);                                                                           // Initializing velocity data...
  acceleration->init (nodes);                                                                       // Initializing acceleration data...

  position_int->init (nodes);                                                                       // Initializing intermediate position data...
  velocity_int->init (nodes);                                                                       // Initializing intermediate position data...
  acceleration_int->init (nodes);                                                                   // Initializing intermediate position data...

  gravity->init (nodes);                                                                            // Initializing gravity data...
  stiffness->init (nodes);                                                                          // Initializing stiffness data...
  resting->init (nodes);                                                                            // Initializing resiting position data...
  friction->init (nodes);                                                                           // Initializing friction data...
  mass->init (nodes);                                                                               // Initializing mass data...

  index_R->init (nodes);                                                                            // Initializing right neighbour index...
  index_U->init (nodes);                                                                            // Initializing up neighbour index...
  index_L->init (nodes);                                                                            // Initializing left neighbour index...
  index_D->init (nodes);                                                                            // Initializing down neighbour index...

  freedom->init (nodes);                                                                            // Initializing freedom flag data...
  dt->init (nodes);                                                                                 // Initializing time step data [s]...

  simulation_time = 0.0;                                                                            // Initializing simulation time [s]...
  time_step_index = 0;                                                                              // Initializing time step index [#]...

  std::cout << "Critical time step = " << dt_critical << "[s]" << std::endl;
  std::cout << "Simulation time step = " << dt_simulation << "[s]" << std::endl;

  for(j = 0; j < nodes_y; j++)
  {
    for(i = 0; i < nodes_x; i++)
    {
      // Computing indexes:
      gid                       = i + nodes_x*j;                                                    // Computing global index...
      neighbour_R               = (i + 1) + nodes_x*j;                                              // Computing right neighbour index...
      neighbour_U               = i + nodes_x*(j + 1);                                              // Computing up neighbour index...
      neighbour_L               = (i - 1) + nodes_x*j;                                              // Computing left neighbour index...
      neighbour_D               = i + nodes_x*(j - 1);                                              // Computing down neighbour index...

      // Setting "x" initial position...
      position->data[gid].x     = x_min + i*dx;                                                     // Setting "x" position...
      position->data[gid].y     = y_min + j*dy;                                                     // Setting "y" position...
      position->data[gid].z     = 0.0;                                                              // Setting "z" position...
      position->data[gid].w     = 1.0;                                                              // Setting "w" position...

      velocity->data[gid].x     = 0.0;                                                              // Setting "x" velocity...
      velocity->data[gid].y     = 0.0;                                                              // Setting "y" velocity...
      velocity->data[gid].z     = 0.0;                                                              // Setting "z" velocity...
      velocity->data[gid].w     = 1.0;                                                              // Setting "w" velocity...

      acceleration->data[gid].x = 0.0;                                                              // Setting "x" acceleration...
      acceleration->data[gid].y = 0.0;                                                              // Setting "y" acceleration...
      acceleration->data[gid].z = 0.0;                                                              // Setting "z" acceleration...
      acceleration->data[gid].w = 1.0;                                                              // Setting "w" acceleration...

      depth->data[gid].x        = 1.0;                                                              // Setting "x" initial color...
      depth->data[gid].y        = 0.0;                                                              // Setting "y" initial color...
      depth->data[gid].z        = 0.0;                                                              // Setting "z" initial color...
      depth->data[gid].w        = 1.0;                                                              // Setting "w" initial color...

      gravity->data[gid].x      = 0.0;                                                              // Setting "x" gravity...
      gravity->data[gid].y      = 0.0;                                                              // Setting "y" gravity...
      gravity->data[gid].z      = -g;                                                               // Setting "z" gravity...
      gravity->data[gid].w      = 1.0;                                                              // Setting "w" gravity...

      stiffness->data[gid].x    = k;                                                                // Setting "x" stiffness...
      stiffness->data[gid].y    = k;                                                                // Setting "y" stiffness...
      stiffness->data[gid].z    = k;                                                                // Setting "z" stiffness...
      stiffness->data[gid].w    = 1.0;                                                              // Setting "w" stiffness...

      resting->data[gid].x      = dx;                                                               // Setting "x" resting position...
      resting->data[gid].y      = dy;                                                               // Setting "y" resting position...
      resting->data[gid].z      = dz;                                                               // Setting "z" resting position...
      resting->data[gid].w      = 1.0;                                                              // Setting "w" resting position...

      friction->data[gid].x     = C;                                                                // Setting "x" friction...
      friction->data[gid].y     = C;                                                                // Setting "y" friction...
      friction->data[gid].z     = C;                                                                // Setting "z" friction...
      friction->data[gid].w     = 1.0;                                                              // Setting "w" friction...

      mass->data[gid].x         = m;                                                                // Setting "x" mass...
      mass->data[gid].y         = m;                                                                // Setting "y" mass...
      mass->data[gid].z         = m;                                                                // Setting "z" mass...
      mass->data[gid].w         = 1.0;                                                              // Setting "w" mass...

      freedom->data[gid].x      = 1.0;                                                              // Setting "x" freedom...
      freedom->data[gid].y      = 1.0;                                                              // Setting "y" freedom...
      freedom->data[gid].z      = 1.0;                                                              // Setting "z" freedom...
      freedom->data[gid].w      = 1.0;                                                              // Setting "w" freedom...

      dt->data[gid]             = dt_simulation;                                                    // Setting time step...

      // When on bulk:
      if(
         (i != border_L) &&                                                                         // Not on left border.
         (i != border_R) &&                                                                         // Not on right border.
         (j != border_D) &&                                                                         // Not on down border.
         (j != border_U)                                                                            // Not on up border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }

      else                                                                                          // When on all borders:
      {
        gravity->data[gid].x = 0.0;                                                                 // Setting "x" gravity...
        gravity->data[gid].y = 0.0;                                                                 // Setting "y" gravity...
        gravity->data[gid].z = 0.0;                                                                 // Setting "z" gravity...
        gravity->data[gid].w = 1.0;                                                                 // Setting "w" gravity...

        freedom->data[gid].x = 0.0;                                                                 // Setting "x" freedom...
        freedom->data[gid].y = 0.0;                                                                 // Setting "y" freedom...
        freedom->data[gid].z = 0.0;                                                                 // Setting "z" freedom...
        freedom->data[gid].w = 0.0;                                                                 // Setting "w" freedom...
      }

      // When on left border (excluding extremes):
      if(
         (i == border_L) &&                                                                         // On left border.
         (j != border_D) &&                                                                         // Not on down border.
         (j != border_U)                                                                            // Not on up border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = gid;
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }

      // When on right border (excluding extremes):
      if(
         (i == border_R) &&                                                                         // On right border.
         (j != border_D) &&                                                                         // Not on down border.
         (j != border_U)                                                                            // Not on up border.
        )
      {
        index_R->data[gid] = gid;
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }

      // When on bottom border (excluding extremes):
      if(
         (j == border_D) &&                                                                         // On down border.
         (i != border_L) &&                                                                         // Not on left border.
         (i != border_R)                                                                            // Not on right border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = gid;                                                                   // Setting index to central node...
      }

      // When on high border (excluding extremes):
      if(
         (j == border_U) &&                                                                         // On up border.
         (i != border_L) &&                                                                         // Not on left border.
         (i != border_R)                                                                            // Not on right border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = gid;                                                                   // Setting index to central node...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }

      // When on bottom left corner:
      if(
         (i == border_L) &&                                                                         // On left border.
         (j == border_D)                                                                            // On down border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = gid;                                                                   // Setting index to central node...
        index_D->data[gid] = gid;                                                                   // Setting index to central node...
      }

      // When on bottom right corner:
      if(
         (i == border_R) &&                                                                         // On right border.
         (j == border_D)                                                                            // On down border.
        )
      {
        index_R->data[gid] = gid;                                                                   // Setting index to central node...
        index_U->data[gid] = neighbour_U;                                                           // Setting index to up neighbour...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = gid;                                                                   // Setting index to central node...
      }

      // When on top left corner:
      if(
         (i == border_L) &&                                                                         // On left border.
         (j == border_U)                                                                            // On up border.
        )
      {
        index_R->data[gid] = neighbour_R;                                                           // Setting index to right neighbour...
        index_U->data[gid] = gid;                                                                   // Setting index to central node...
        index_L->data[gid] = gid;                                                                   // Setting index to central node...
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }

      // When on top right corner:
      if(
         (i == border_R) &&                                                                         // On right border.
         (j == border_U)                                                                            // On up border.
        )
      {
        index_R->data[gid] = gid;                                                                   // Setting index to central node...
        index_U->data[gid] = gid;                                                                   // Setting index to central node...
        index_L->data[gid] = neighbour_L;                                                           // Setting index to left neighbour...
        index_D->data[gid] = neighbour_D;                                                           // Setting index to down neighbour...
      }
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////// NEUTRINO INITIALIZATION /////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  bas->init (QUEUE_NUM, KERNEL_NUM, INTEROP);                                                       // Initializing Neutrino baseline...
  gui->init
  (
   bas,                                                                                             // Neutrino baseline.
   GUI_SIZE_X,                                                                                      // GUI x-size [px].
   GUI_SIZE_Y,                                                                                      // GUI y-size [px.]
   GUI_NAME,                                                                                        // GUI name.
   orbit_x_init,                                                                                    // Initial x-orbit.
   orbit_y_init,                                                                                    // Initial y-orbit.
   pan_x_init,                                                                                      // Initial x-pan.
   pan_y_init,                                                                                      // Initial y-pan.
   pan_z_init                                                                                       // Initial z-pan.
  );
  ctx->init (bas, gui, NU_GPU);                                                                     // Initializing OpenCL context...
  S->init (bas, SHADER_HOME, SHADER_VERT, SHADER_GEOM, SHADER_FRAG);                                // Initializing OpenGL shader...
  Q->init (bas);                                                                                    // Initializing OpenCL queue...
  K1->init (bas, KERNEL_HOME, KERNEL_F1, kernel_sx, kernel_sy, kernel_sz);                          // Initializing OpenCL kernel K1...
  K2->init (bas, KERNEL_HOME, KERNEL_F2, kernel_sx, kernel_sy, kernel_sz);                          // Initializing OpenCL kernel K2...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////// SETTING OPENCL KERNEL ARGUMENTS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  K1->setarg (position, 0);                                                                         // Setting position kernel argument...
  K1->setarg (depth, 1);                                                                            // Setting depth kernel argument...
  K1->setarg (position_int, 2);                                                                     // Setting intermediate position kernel argument...
  K1->setarg (velocity, 3);                                                                         // Setting velocity kernel argument...
  K1->setarg (velocity_int, 4);                                                                     // Setting intermediate velocity kernel argument...
  K1->setarg (acceleration, 5);                                                                     // Setting acceleration kernel argument...
  K1->setarg (acceleration_int, 6);                                                                 // Setting intermediate acceleration kernel argument...
  K1->setarg (gravity, 7);                                                                          // Setting gravity kernel argument...
  K1->setarg (stiffness, 8);                                                                        // Setting stiffness kernel argument...
  K1->setarg (resting, 9);                                                                          // Setting resting position kernel argument...
  K1->setarg (friction, 10);                                                                        // Setting friction kernel argument...
  K1->setarg (mass, 11);                                                                            // Setting mass kernel argument...
  K1->setarg (index_R, 12);                                                                         // Setting right neighbour index kernel argument...
  K1->setarg (index_U, 13);                                                                         // Setting up neighbour index kernel argument...
  K1->setarg (index_L, 14);                                                                         // Setting left neighbour index kernel argument...
  K1->setarg (index_D, 15);                                                                         // Setting down neighbour index kernel argument...
  K1->setarg (freedom, 16);                                                                         // Setting freedom flag kernel argument...
  K1->setarg (dt, 17);                                                                              // Setting time step kernel argument...

  K2->setarg (position, 0);                                                                         // Setting position kernel argument...
  K2->setarg (depth, 1);                                                                            // Setting depth kernel argument...
  K2->setarg (position_int, 2);                                                                     // Setting intermediate position kernel argument...
  K2->setarg (velocity, 3);                                                                         // Setting velocity kernel argument...
  K2->setarg (velocity_int, 4);                                                                     // Setting intermediate velocity kernel argument...
  K2->setarg (acceleration, 5);                                                                     // Setting acceleration kernel argument...
  K2->setarg (acceleration_int, 6);                                                                 // Setting intermediate acceleration kernel argument...
  K2->setarg (gravity, 7);                                                                          // Setting gravity kernel argument...
  K2->setarg (stiffness, 8);                                                                        // Setting stiffness kernel argument...
  K2->setarg (resting, 9);                                                                          // Setting resting position kernel argument...
  K2->setarg (friction, 10);                                                                        // Setting friction kernel argument...
  K2->setarg (mass, 11);                                                                            // Setting mass kernel argument...
  K2->setarg (index_R, 12);                                                                         // Setting right neighbour index kernel argument...
  K2->setarg (index_U, 13);                                                                         // Setting up neighbour index kernel argument...
  K2->setarg (index_L, 14);                                                                         // Setting left neighbour index kernel argument...
  K2->setarg (index_D, 15);                                                                         // Setting down neighbour index kernel argument...
  K2->setarg (freedom, 16);                                                                         // Setting freedom flag kernel argument...
  K2->setarg (dt, 17);                                                                              // Setting time step kernel argument...

  position->name = "voxel_center";                                                                  // Setting variable name for OpenGL shader...
  depth->name    = "voxel_color";                                                                   // Setting variable name for OpenGL shader...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// WRITING DATA ON OPENCL QUEUE //////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  Q->write (position, 0);                                                                           // Writing position data on queue...
  Q->write (depth, 1);                                                                              // Writing depth data on queue...
  Q->write (position_int, 2);                                                                       // Writing intermediate position data on queue...
  Q->write (velocity, 3);                                                                           // Writing velocity data on queue...
  Q->write (velocity_int, 4);                                                                       // Writing intermediate velocity data on queue...
  Q->write (acceleration, 5);                                                                       // Writing acceleration data on queue...
  Q->write (acceleration_int, 6);                                                                   // Writing intermediate acceleration data on queue...
  Q->write (gravity, 7);                                                                            // Writing gravity data on queue...
  Q->write (stiffness, 8);                                                                          // Writing stiffness data on queue...
  Q->write (resting, 9);                                                                            // Writing resting position data on queue...
  Q->write (friction, 10);                                                                          // Writing friction data on queue...
  Q->write (mass, 11);                                                                              // Writing mass data on queue...
  Q->write (index_R, 12);                                                                           // Writing right neighbour index on queue...
  Q->write (index_U, 13);                                                                           // Writing up neighbour index on queue...
  Q->write (index_L, 14);                                                                           // Writing left neighbour index on queue...
  Q->write (index_D, 15);                                                                           // Writing down neighbour index on queue...
  Q->write (freedom, 16);                                                                           // Writing freedom flag data on queue...
  Q->write (dt, 17);                                                                                // Writing time step data on queue...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////// SETTING OPENGL SHADER ARGUMENTS ////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  S->setarg (position, 0);                                                                          // Setting shader argument "0"...
  S->setarg (depth, 1);                                                                             // Setting shader argument "1"...
  S->build ();                                                                                      // Building shader program...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////// APPLICATION LOOP ////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  while(!gui->closed ())                                                                            // Opening window...
  {
    bas->get_tic ();                                                                                // Getting "tic" [us]...

    gui->clear ();                                                                                  // Clearing gui...
    gui->poll_events ();                                                                            // Polling gui events...

    Q->acquire (position, 0);                                                                       // Acquiring OpenGL/CL shared argument...
    Q->acquire (depth, 1);                                                                          // Acquiring OpenGL/CL shared argument...
    ctx->execute (K1, Q, NU_WAIT);                                                                  // Executing OpenCL kernel...
    ctx->execute (K2, Q, NU_WAIT);                                                                  // Executing OpenCL kernel...
    Q->release (position, 0);                                                                       // Releasing OpenGL/CL shared argument...
    Q->release (depth, 1);                                                                          // Releasing OpenGL/CL shared argument...

    orbit_x = gui->axis_LEFT_X;                                                                     // Setting "Near clipping-plane" x-coordinate...
    orbit_y = -gui->axis_LEFT_Y;                                                                    // Setting "Near clipping-plane" y-coordinate...

    gui->orbit (
                orbit_x,                                                                            // "Near clipping-plane" x-coordinate.
                orbit_y,                                                                            // "Near clipping-plane" y-coordinate.
                orbit_rate,                                                                         // Orbit angular rate coefficient [rev/s].
                orbit_deadzone,                                                                     // Orbit deadzone threshold coefficient.
                orbit_decaytime                                                                     // Orbit low pass decay time [s].
               );

    pan_x   = +gui->axis_RIGHT_X;                                                                   // Setting world x-pan...
    pan_y   = -gui->axis_RIGHT_Y;                                                                   // Setting world y-pan...
    pan_z   = (gui->axis_RIGHT_TRIGGER + 1.0)/2.0 - (gui->axis_LEFT_TRIGGER + 1.0)/2.0;             // Setting world z-pan...

    gui->pan (
              pan_x,                                                                                // World x-pan.
              pan_y,                                                                                // World y-pan.
              pan_z,                                                                                // World z-pan.
              pan_rate,                                                                             // Pan rate [length/s].
              pan_deadzone,                                                                         // Pan deadzone threshold coefficient.
              pan_decaytime                                                                         // Pan low pass decay time [s].
             );

    if(gui->button_CROSS)
    {
      gui->close ();                                                                                // Closing gui...
    }

    gui->plot (S);                                                                                  // Plotting shared arguments...

    gui->refresh ();                                                                                // Refreshing gui...

    simulation_time += dt_simulation;                                                               // Updating simulation time [s]...
    time_step_index++;                                                                              // Updating time step index [#]...

    bas->get_toc ();                                                                                // Getting "toc" [us]...
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////// CLEANUP ////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  delete bas;                                                                                       // Deleting Neutrino baseline...
  delete gui;                                                                                       // Deleting OpenGL gui...
  delete ctx;                                                                                       // Deleting OpenCL context...

  delete position;                                                                                  // Deleting position data...
  delete depth;                                                                                     // Deleting depth data...
  delete velocity;                                                                                  // Deleting velocity data...
  delete acceleration;                                                                              // Deleting acceleration data...

  delete position_int;                                                                              // Deleting intermediate position data...
  delete velocity_int;                                                                              // Deleting intermediate velocity data...
  delete acceleration_int;                                                                          // Deleting intermediate acceleration data...

  delete gravity;                                                                                   // Deleting gravity data...
  delete stiffness;                                                                                 // Deleting stiffness data...
  delete resting;                                                                                   // Deleting resting data...
  delete friction;                                                                                  // Deleting friction data...
  delete mass;                                                                                      // Deleting mass data...

  delete index_R;                                                                                   // Deleting right neighbour index...
  delete index_U;                                                                                   // Deleting up neighbour index...
  delete index_L;                                                                                   // Deleting left neighbour index...
  delete index_D;                                                                                   // Deleting down neighbour index...

  delete freedom;                                                                                   // Deleting freedom flag data...
  delete dt;                                                                                        // Deleting time step data...

  delete Q;                                                                                         // Deleting OpenCL queue...
  delete K1;                                                                                        // Deleting OpenCL kernel...
  delete K2;                                                                                        // Deleting OpenCL kernel...

  return 0;
}
